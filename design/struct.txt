// You can define structures with the struct keyword. You don't seperate the fields with a comma.
// If you wish, you can seperate the fields with a semicolon, but it isn't necessary.
struct Person {
    name (string)
    age (uint)
}

// By default, all these are private. You can make them public with the "pub" keyword.
struct Person {
    pub name (string)
    pub age (uint)
}

// You can create a struct very similarly to Rust.
let my_person = Person {
    name = "Jeff"
    age = 25
}

// You can add a constructor to this struct by making a function with the same name.
// If you do this, you don't need a return type.
fun Person( name (string) age (uint) ) {
    return Person {
        name = name
        age = age
    }
}

// If you make a constructor, you can initialize a struct like this:
let my_person (Person) = Person("Jeff", 25)

// You need to use an "implement" block to add functions into a struct like this.
// All functions in this implement block are private by default. Use the "pub" keyword
// to make them public.
implement Person {
    pub fun get_age( self ) returns uint {
        return self.age
    }
}

// You may want shared behavior between different structs. Create an interface for this.
// Each line in the interface has the name of the function and it's return type. This allows
// for unique parameters in each implementation. However, you also can force it to have certain
// parameters.
interface Person {
    get_age returns uint
    set_name( self name (string) ) // This must have these parameters.
}

// To implement this interface, use this:
struct Programmer {
    name (string)
    age (uint)
}

implement Person into Programmer {
    fun get_age( self ) returns uint {
        return self.age
    }

    fun set_name( self name (string) ) {
        self.name = name
    }
}

// Sometimes, you want shared fields in structs. You can do this with a Template.
template Person {
    name (string)
    age (uint)
}

// You can use this template as such. The fields are automatically added.
struct Programmer from Person {
    favorite_language (string)
}

// If you want a type of a struct that has a template in it, you can do this:
let person (from Person) = ...

// If you want the type of a struct that has an interface, you can do this:
let person (implements Person) = ...

// You can stack these!
let person (from Person implements Person) = ...

// Notice these have the same name. You can have the same identifier for a template, struct,
// and interface with no issues. The compiler deals with it. If you need to specify for whatever
// reason, you can use ":" syntax. It will specify which kind of Person you want.
// If this is confusing or annoying to you, you can define your own types for these.
let person (from Person:template) = ...
let person (implements Person:interface) = ...
let person (Person:struct)